# -*- coding: utf-8 -*-
"""EPL - Streamlit.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cEz7NWkbTosCjo69zoSLL5elBKtgH0x1
"""

import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import MinMaxScaler
from sklearn.model_selection import train_test_split
from sklearn.multioutput import MultiOutputRegressor
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import accuracy_score

def read_data(file):
  # Import csv file into dataframe
  df = pd.read_csv(file, index_col=False)

  # Clean imported dataframe
  df = df.drop(columns=['Unnamed: 0'])
  df['Attendance'] = df['Attendance'].fillna(df['Attendance'].median())
  df = df.dropna()
  df['GF'] = df['Score'].str[:1]
  df['GA'] = df['Score'].str[-1:]
  df['GF'] = df['GF'].astype('Int64')
  df['GA'] = df['GA'].astype('Int64')
  df['Attendance'] = df['Attendance'].astype('Int64')
  df = df.drop(columns=['Score'])
  df['Date'] = pd.to_datetime(df['Date'])
  df['Time'] = df['Time'].str[:2]
  df['Time'] = pd.to_datetime(df['Time'], format='%H', errors='coerce').dt.time

  return df

def rolling_home(df, window=5):
  # Create new columns to store the rolling averages
  df['Rolling_Avg_xG_Home'] = 0.0
  df['Rolling_Avg_xG_Away'] = 0.0
  df['Rolling_Avg_GF'] = 0.0
  df['Rolling_Avg_GA'] = 0.0
  df['Rolling_Avg_Attendance'] = 0.0

  for index, row in df.iterrows():
    home_team = row['Home']
    # Get the last 'window' rows with the same home team
    previous_matches = df[(df['Home'] == home_team) & (df.index < index)].tail(window)

    #Calculate the rolling averages for the current row (excluding current row)
    if not previous_matches.empty:
      df.loc[index, 'Rolling_Avg_xG_Home'] = previous_matches['xG_Home'].mean()
      df.loc[index, 'Rolling_Avg_xG_Away'] = previous_matches['xG_Away'].mean()
      df.loc[index, 'Rolling_Avg_GF'] = previous_matches['GF'].mean()
      df.loc[index, 'Rolling_Avg_GA'] = previous_matches['GA'].mean()
      df.loc[index, 'Rolling_Avg_Attendance'] = previous_matches['Attendance'].mean()
    else:
      # Handle cases where there are fewer than 'window' previous matches
      df.loc[index, 'Rolling_Avg_xG_Home'] = row['xG_Home']
      df.loc[index, 'Rolling_Avg_xG_Away'] = row['xG_Away']
      df.loc[index, 'Rolling_Avg_GF'] = row['GF']
      df.loc[index, 'Rolling_Avg_GA'] = row['GA']
      df.loc[index, 'Rolling_Avg_Attendance'] = row['Attendance']

  return df

def rolling_home_away(group, window=5):
  # Calculate rolling means with the same home and away team (excluding current row)
  group['Rolling_xG_Home'] = group['xG_Home'].shift(1).rolling(window=window, min_periods=0).mean()
  group['Rolling_xG_Away'] = group['xG_Away'].shift(1).rolling(window=window, min_periods=0).mean()
  group['Rolling_GF'] = group['GF'].shift(1).rolling(window=window, min_periods=0).mean()
  group['Rolling_GA'] = group['GA'].shift(1).rolling(window=window, min_periods=0).mean()
  group['Rolling_Attendance'] = group['Attendance'].shift(1).rolling(window=window, min_periods=0).mean()

  # Fill NaN values with the current row's value if no previous rows
  group['Rolling_xG_Home'] = group['Rolling_xG_Home'].fillna(group['xG_Home'])
  group['Rolling_xG_Away'] = group['Rolling_xG_Away'].fillna(group['xG_Away'])
  group['Rolling_GF'] = group['Rolling_GF'].fillna(group['GF'])
  group['Rolling_GA'] = group['Rolling_GA'].fillna(group['GA'])
  group['Rolling_Attendance'] = group['Rolling_Attendance'].fillna(group['Attendance'])

  return group

def sort_data(group):
  # Roll and sort dataframe with the same home and away team
  roll_df = df.groupby(['Home', 'Away']).apply(rolling_home_away).reset_index(drop=True)
  roll_df = roll_df.drop(columns=['Date'])
  roll_df = roll_df.drop(columns=['Time'])

  return roll_df

def encode_data(roll_df):
  # Encode categorical column based on mean

  categorical_cols = ['Day', 'Home', 'Away', 'Venue', 'Referee']

  # Create an empty dictionary to store the dataframes for GF
  pivot_tables_GF = {}

  for col in categorical_cols:
      # Create pivot table and store it in the dictionary
      pivot_tables_GF[col + '_GF'] = roll_df.pivot_table(
          index=col,
          values=['GF'],
          aggfunc=[np.mean]
      )

  # Create an empty dictionary to store the dataframes for GA
  pivot_tables_GA = {}

  for col in categorical_cols:
      # Create pivot table and store it in the dictionary
      pivot_tables_GA[col + '_GA'] = roll_df.pivot_table(
          index=col,
          values=['GA'],
          aggfunc=[np.mean]
      )

  for col in categorical_cols:
      # Reset the index of the pivot table
      pivot_tables_GF[col + '_GF'] = pivot_tables_GF[col + '_GF'].reset_index()
      pivot_tables_GA[col + '_GA'] = pivot_tables_GA[col + '_GA'].reset_index()

  # Loop through categorical columns
  for cat_col in categorical_cols:
      # Get the key for the current categorical column in pivot_tables_GF
      key_gf = cat_col + '_GF'

      # Rename columns for GF pivot table
      new_col_names_gf = []
      for column in pivot_tables_GF[key_gf].columns.get_level_values(0).tolist():
          if column == cat_col:  # Check if it's the original column name
              new_col_names_gf.append(column)
          else:
              label = column + '_' + key_gf  # Create a descriptive label
              new_col_names_gf.append(label)

      pivot_tables_GF[key_gf].columns = new_col_names_gf  # Rename columns

      # Create a separate dataframe for the current GF pivot table
      globals()[key_gf.lower() + '_df'] = pd.DataFrame(pivot_tables_GF[key_gf])

      # Rename columns for GA pivot table
      key_ga = cat_col + '_GA'
      new_col_names_ga = []
      for column in pivot_tables_GA[key_ga].columns.get_level_values(0).tolist():
          if column == cat_col:
              new_col_names_ga.append(column)
          else:
              label = column + '_' + key_ga
              new_col_names_ga.append(label)

      pivot_tables_GA[key_ga].columns = new_col_names_ga

      # Create a separate dataframe for the current GA pivot table
      globals()[key_ga.lower() + '_df'] = pd.DataFrame(pivot_tables_GA[key_ga])

  # Merge GF dataframe
  for cat_col in categorical_cols:
      key_gf = cat_col + '_GF'
      roll_df = pd.merge(roll_df, globals()[key_gf.lower() + '_df'], on=cat_col, how='left')

  # Merge GA dataframe
  for cat_col in categorical_cols:
      key_ga = cat_col + '_GA'
      roll_df = pd.merge(roll_df, globals()[key_ga.lower() + '_df'], on=cat_col, how='left')

  return roll_df

def normalization_data(roll_df):
  # Create a scaler
  scaler = MinMaxScaler()

  # Select the numerical columns to normalize
  numerical_cols = roll_df.select_dtypes(include=np.number).columns
  numerical_cols = [col for col in numerical_cols if col not in ['GF', 'GA']]

  # Fit the scaler on the numerical data and transform it
  roll_df_normal = roll_df.copy()
  roll_df_normal[numerical_cols] = scaler.fit_transform(roll_df[numerical_cols])

  return roll_df_normal

# Create model with Random Forest Regressor

def rf_regressor(roll_df_normal):
  # Drop specified columns
  categorical_cols = ['Day', 'Home', 'Away', 'Venue', 'Referee']
  roll_df_normal = roll_df_normal.drop(columns=['xG_Home', 'xG_Away', 'Attendance',
                                    'mean_Day_GF', 'mean_Referee_GF',
                                    'mean_Day_GA', 'mean_Referee_GA']
                           )
  roll_df_normal = roll_df_normal.drop(columns=categorical_cols)

  # Create target and feature array
  a = roll_df_normal[['GF','GA']].iloc[:-10]

  b = roll_df_normal.iloc[:-10, (roll_df_normal.columns != 'GF') & (roll_df_normal.columns != 'GA')]

  target = np.array(a)
  feature = np.array(b)

  # Train and test split

  X_train, y_train = feature, target
  X_train,X_test, y_train,y_test = train_test_split(X_train, y_train, test_size=0.2,random_state=40)

  # Create and fit the model
  model = MultiOutputRegressor(RandomForestRegressor(min_samples_split=2,
                                                   random_state=8))
  model.fit(X_train, y_train)
  y_pred = model.predict(X_test)

  return model

def create_new_df(roll_df, home_team, away_team):
  # Create a new DataFrame with the required columns for prediction
    new_df = pd.DataFrame({
        'Home': [home_team],
        'Away': [away_team],
        'Rolling_Avg_xG_Home': roll_df.loc[(roll_df['Home'] == home_team), 'Rolling_Avg_xG_Home'].iloc[-1],
        'Rolling_Avg_xG_Away': roll_df.loc[(roll_df['Away'] == away_team), 'Rolling_Avg_xG_Away'].iloc[-1],
        'Rolling_Avg_GF': roll_df.loc[(roll_df['Home'] == home_team), 'Rolling_Avg_GF'].iloc[-1],
        'Rolling_Avg_GA': roll_df.loc[(roll_df['Away'] == away_team), 'Rolling_Avg_GA'].iloc[-1],
        'Rolling_Avg_Attendance': roll_df.loc[(roll_df['Home'] == home_team), 'Rolling_Avg_Attendance'].iloc[-1],
        'Rolling_xG_Home': roll_df.loc[(roll_df['Home'] == home_team) & (roll_df['Away'] == away_team), 'Rolling_xG_Home'].iloc[-1],
        'Rolling_xG_Away': roll_df.loc[(roll_df['Home'] == home_team) & (roll_df['Away'] == away_team), 'Rolling_xG_Away'].iloc[-1],
        'Rolling_GF': roll_df.loc[(roll_df['Home'] == home_team)  & (roll_df['Away'] == away_team), 'Rolling_GF'].iloc[-1],
        'Rolling_GA': roll_df.loc[(roll_df['Home'] == home_team) & (roll_df['Away'] == away_team), 'Rolling_GA'].iloc[-1],
        'Rolling_Attendance': roll_df.loc[(roll_df['Home'] == home_team)  & (roll_df['Away'] == away_team), 'Rolling_Attendance'].iloc[-1],
        'mean_Home_GF': roll_df.loc[(roll_df['Home'] == home_team), 'mean_Home_GF'].iloc[0],
        'mean_Away_GF': roll_df.loc[(roll_df['Home'] == home_team) & (roll_df['Away'] == away_team), 'mean_Away_GF'].iloc[0],
        'mean_Venue_GF': roll_df.loc[(roll_df['Home'] == home_team), 'mean_Venue_GF'].iloc[0],
        'mean_Home_GA': roll_df.loc[(roll_df['Home'] == home_team), 'mean_Home_GA'].iloc[0],
        'mean_Away_GA': roll_df.loc[(roll_df['Home'] == home_team) & (roll_df['Away'] == away_team), 'mean_Away_GA'].iloc[0],
        'mean_Venue_GA': roll_df.loc[(roll_df['Home'] == home_team), 'mean_Venue_GA'].iloc[0],
    })
    new_df = new_df.drop(columns=(new_df.select_dtypes(include=['object']).columns))

    return new_df

def predict_data(roll_df, home_team, away_team):
  # Create new data to be used for prediction
  def create_new_df(roll_df, home_team, away_team):
    # Create a new dataframe with the required columns
    new_df = pd.DataFrame({
        'Home': [home_team],
        'Away': [away_team],
        'Rolling_Avg_xG_Home': roll_df.loc[(roll_df['Home'] == home_team), 'Rolling_Avg_xG_Home'].iloc[-1],
        'Rolling_Avg_xG_Away': roll_df.loc[(roll_df['Away'] == away_team), 'Rolling_Avg_xG_Away'].iloc[-1],
        'Rolling_Avg_GF': roll_df.loc[(roll_df['Home'] == home_team), 'Rolling_Avg_GF'].iloc[-1],
        'Rolling_Avg_GA': roll_df.loc[(roll_df['Away'] == away_team), 'Rolling_Avg_GA'].iloc[-1],
        'Rolling_Avg_Attendance': roll_df.loc[(roll_df['Home'] == home_team), 'Rolling_Avg_Attendance'].iloc[-1],
        'Rolling_xG_Home': roll_df.loc[(roll_df['Home'] == home_team) & (roll_df['Away'] == away_team), 'Rolling_xG_Home'].iloc[-1],
        'Rolling_xG_Away': roll_df.loc[(roll_df['Home'] == home_team) & (roll_df['Away'] == away_team), 'Rolling_xG_Away'].iloc[-1],
        'Rolling_GF': roll_df.loc[(roll_df['Home'] == home_team)  & (roll_df['Away'] == away_team), 'Rolling_GF'].iloc[-1],
        'Rolling_GA': roll_df.loc[(roll_df['Home'] == home_team) & (roll_df['Away'] == away_team), 'Rolling_GA'].iloc[-1],
        'Rolling_Attendance': roll_df.loc[(roll_df['Home'] == home_team)  & (roll_df['Away'] == away_team), 'Rolling_Attendance'].iloc[-1],
        'mean_Home_GF': roll_df.loc[(roll_df['Home'] == home_team), 'mean_Home_GF'].iloc[0],
        'mean_Away_GF': roll_df.loc[(roll_df['Home'] == home_team) & (roll_df['Away'] == away_team), 'mean_Away_GF'].iloc[0],
        'mean_Venue_GF': roll_df.loc[(roll_df['Home'] == home_team), 'mean_Venue_GF'].iloc[0],
        'mean_Home_GA': roll_df.loc[(roll_df['Home'] == home_team), 'mean_Home_GA'].iloc[0],
        'mean_Away_GA': roll_df.loc[(roll_df['Home'] == home_team) & (roll_df['Away'] == away_team), 'mean_Away_GA'].iloc[0],
        'mean_Venue_GA': roll_df.loc[(roll_df['Home'] == home_team), 'mean_Venue_GA'].iloc[0],
    })
    new_df = new_df.drop(columns=(new_df.select_dtypes(include=['object']).columns))

    return new_df

  # Create new array for prediction
  new_np = np.array(create_new_df(roll_df, home_team, away_team))

  # Make prediction
  new_test = model.predict(new_np)
  new_test = pd.DataFrame(new_test, columns=['GF','GA'])
  st.write(f"{home_team} score prediction: {new_test['GF'].values[0]}")
  st.write(f"{away_team} score prediction: {new_test['GA'].values[0]}")

def plot_timeline(roll_df, home_team, away_team, window_size=5):
  # Filter the dataframe to include only games between the specified teams
  team_df = roll_df[(roll_df['Home'] == home_team) & (roll_df['Away'] == away_team)].copy()

  if team_df.empty:
      print(f"No match found between {home_team} and {away_team}.")
      return

  # Get the actual number of matches, up to window_size
  actual_window_size = min(len(team_df), window_size)

  # Extract the relevant columns
  home_xg = team_df['GF'].tail(actual_window_size)
  away_xg = team_df['GA'].tail(actual_window_size)
  match_dates = team_df.index[-actual_window_size:]

  # Create x-axis values (1, 2, 3, 4, ...)
  x_values = list(range(1, actual_window_size + 1))

  # Create the plot
  plt.figure(figsize=(10, 4))

  # Fill the area under the lines
  plt.fill_between(x_values, home_xg, 0, alpha=0.3)
  plt.fill_between(x_values, away_xg, 0, alpha=0.3)

  plt.plot(x_values, home_xg, label=f"{home_team} (Home)", marker='o')
  plt.plot(x_values, away_xg, label=f"{away_team} (Away)", marker='x')

  for i, txt in enumerate(home_xg):
       plt.annotate(f"{txt:.2f}", (x_values[i], home_xg.iloc[i]), textcoords="offset points", xytext=(0,10), ha='center')
  for i, txt in enumerate(away_xg):
       plt.annotate(f"{txt:.2f}", (x_values[i], away_xg.iloc[i]), textcoords="offset points", xytext=(0,10), ha='center')

  plt.xlabel("Recent Matches")
  plt.ylabel("Goals")
  plt.title(f"Last {actual_window_size} Meets at Home: {home_team} vs. {away_team}")
  plt.legend()
  plt.grid(True)

  # Set x-axis ticks and labels
  plt.xticks(x_values)

  plt.tight_layout()
  plt.show()

df = read_data('epl-2017-2025-03-20.csv')

df = rolling_home(df)

df = rolling_home_away(df)

roll_df = sort_data(df)

roll_df = encode_data(roll_df)

roll_df_normal = normalization_data(roll_df)

model = rf_regressor(roll_df_normal)

predict_data(roll_df_normal, 'Arsenal', 'Sheffield Utd')

plot_timeline(roll_df, 'Arsenal', 'Sheffield Utd')

