# -*- coding: utf-8 -*-
"""EPL - Streamlit.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cEz7NWkbTosCjo69zoSLL5elBKtgH0x1
"""

!pip install streamlit
import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

st.header('Can Your Team Win?')
st.write('English Premier League Version')
st.write('This is for FUN only. I made this because I need a portfolio for my data science job (LOL).')
df = pd.read_csv('epl-2017-2025-03-20.csv', index_col=False)
df = df.drop(columns=['Unnamed: 0'])
df['Attendance'] = df['Attendance'].fillna(df['Attendance'].median())
df = df.dropna()
df['GF'] = df['Score'].str[:1]
df['GA'] = df['Score'].str[-1:]
df['GF'] = df['GF'].astype('Int64')
df['GA'] = df['GA'].astype('Int64')
df['Attendance'] = df['Attendance'].astype('Int64')
df = df.drop(columns=['Score'])
df['Date'] = pd.to_datetime(df['Date'])
df['Time'] = df['Time'].str[:2]
df['Time'] = pd.to_datetime(df['Time'], format='%H', errors='coerce').dt.time

def rolling_avg_by_home_team(df, window=5):
  # Create new columns to store the rolling averages
  df['Rolling_Avg_xG_Home'] = 0.0
  df['Rolling_Avg_xG_Away'] = 0.0
  df['Rolling_Avg_GF'] = 0.0
  df['Rolling_Avg_GA'] = 0.0
  df['Rolling_Avg_Attendance'] = 0.0

  for index, row in df.iterrows():
    home_team = row['Home']
    # Get the last 'window' rows with the same home team
    previous_matches = df[(df['Home'] == home_team) & (df.index < index)].tail(window)

    #Calculate the rolling averages for the current row
    if not previous_matches.empty:
      df.loc[index, 'Rolling_Avg_xG_Home'] = previous_matches['xG_Home'].mean()
      df.loc[index, 'Rolling_Avg_xG_Away'] = previous_matches['xG_Away'].mean()
      df.loc[index, 'Rolling_Avg_GF'] = previous_matches['GF'].mean()
      df.loc[index, 'Rolling_Avg_GA'] = previous_matches['GA'].mean()
      df.loc[index, 'Rolling_Avg_Attendance'] = previous_matches['Attendance'].mean()
    else:
      # Handle cases where there are fewer than 'window' previous matches
      df.loc[index, 'Rolling_Avg_xG_Home'] = row['xG_Home']
      df.loc[index, 'Rolling_Avg_xG_Away'] = row['xG_Away']
      df.loc[index, 'Rolling_Avg_GF'] = row['GF']
      df.loc[index, 'Rolling_Avg_GA'] = row['GA']
      df.loc[index, 'Rolling_Avg_Attendance'] = row['Attendance']

  return df

# Apply the function to the DataFrame
df = rolling_avg_by_home_team(df)

def calculate_rolling_stats(group, window=5):
    # Calculate rolling means (excluding current row)
    group['Rolling_xG_Home'] = group['xG_Home'].shift(1).rolling(window=window, min_periods=0).mean()
    group['Rolling_xG_Away'] = group['xG_Away'].shift(1).rolling(window=window, min_periods=0).mean()
    group['Rolling_GF'] = group['GF'].shift(1).rolling(window=window, min_periods=0).mean()
    group['Rolling_GA'] = group['GA'].shift(1).rolling(window=window, min_periods=0).mean()
    group['Rolling_Attendance'] = group['Attendance'].shift(1).rolling(window=window, min_periods=0).mean()

    # Fill NaN values with the current row's value if no previous rows
    group['Rolling_xG_Home'] = group['Rolling_xG_Home'].fillna(group['xG_Home'])
    group['Rolling_xG_Away'] = group['Rolling_xG_Away'].fillna(group['xG_Away'])
    group['Rolling_GF'] = group['Rolling_GF'].fillna(group['GF'])
    group['Rolling_GA'] = group['Rolling_GA'].fillna(group['GA'])
    group['Rolling_Attendance'] = group['Rolling_Attendance'].fillna(group['Attendance'])

    return group

# Apply the function to the DataFrame using groupby and apply
roll_df = df.groupby(['Home', 'Away']).apply(calculate_rolling_stats).reset_index(drop=True)
roll_df = roll_df.drop(columns=['Date'])
roll_df = roll_df.drop(columns=['Time'])

categorical_cols = ['Day', 'Home', 'Away', 'Venue', 'Referee']

# Create an empty dictionary to store the DataFrames
pivot_tables_GF = {}

for col in categorical_cols:
    # Create pivot table and store it in the dictionary
    pivot_tables_GF[col + '_GF'] = roll_df.pivot_table(
        index=col,
        values=['GF'],
        aggfunc=[np.mean]
    )

# Create an empty dictionary to store the DataFrames
pivot_tables_GA = {}

for col in categorical_cols:
    # Create pivot table and store it in the dictionary
    pivot_tables_GA[col + '_GA'] = roll_df.pivot_table(
        index=col,
        values=['GA'],
        aggfunc=[np.mean]
    )

for col in categorical_cols:
    # Reset the index of the pivot table
    pivot_tables_GF[col + '_GF'] = pivot_tables_GF[col + '_GF'].reset_index()
    pivot_tables_GA[col + '_GA'] = pivot_tables_GA[col + '_GA'].reset_index()

# Merge GF DataFrames
for cat_col in categorical_cols:
    key_gf = cat_col + '_GF'
    roll_df = pd.merge(roll_df, globals()[key_gf.lower() + '_df'], on=cat_col, how='left')

# Merge GA DataFrames
for cat_col in categorical_cols:
    key_ga = cat_col + '_GA'
    roll_df = pd.merge(roll_df, globals()[key_ga.lower() + '_df'], on=cat_col, how='left')

!pip install scikit-learn
from sklearn.preprocessing import MinMaxScaler
from sklearn.model_selection import train_test_split
from sklearn.multioutput import MultiOutputRegressor
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import accuracy_score

# Create a MinMaxScaler object
scaler = MinMaxScaler()

# Select the numerical columns to normalize
numerical_cols = roll_df.select_dtypes(include=np.number).columns
numerical_cols = [col for col in numerical_cols if col not in ['GF', 'GA']]

# Fit the scaler on the numerical data and transform it
roll_df_normal = roll_df.copy()
roll_df_normal[numerical_cols] = scaler.fit_transform(roll_df[numerical_cols])

# Create new dataframe without specified columns
roll_df_3 = roll_df_normal.drop(columns=['xG_Home', 'xG_Away', 'Attendance',
                                  'mean_Day_GF', 'mean_Referee_GF',
                                  'mean_Day_GA', 'mean_Referee_GA']
                         )
roll_df_3 = roll_df_3.drop(columns=categorical_cols)
roll_df_3.head(2)

# Try Random Forest Regressor

a = roll_df_3[['GF','GA']].iloc[:-10]

b = roll_df_3.iloc[:-10, (roll_df_3.columns != 'GF') & (roll_df_3.columns != 'GA')]

target = np.array(a)
feature = np.array(b)

X_train, y_train = feature, target

X_train,X_test, y_train,y_test = train_test_split(X_train, y_train, test_size=0.2,random_state=40)

# Create and fit the model
mor3 = MultiOutputRegressor(RandomForestRegressor(min_samples_split=2,
                                                 random_state=8))
mor3.fit(X_train, y_train)
y_pred3 = mor3.predict(X_test)

# Evaluate the model (calculate R-squared, etc.)
r2 = mor3.score(X_test, y_test)
print(f"Random Forest R-squared: {r2}")

# prompt: i want to create a function that will trigger to create dataframe contain these columns below:
# 1. Home: this manual input from user
# 2. Away: this is also manual input
# 3. Rolling_Avg_xG_Home: create rolling value of colum Home and Away with the same code in roll_df
#  3   Rolling_Avg_xG_Away: create rolling value of colum Home and Away with the same code in roll_df
#  4   Rolling_Avg_GF: create rolling value of colum Home and Away with the same code in roll_df
#  5   Rolling_Avg_GA: create rolling value of colum Home and Away with the same code in roll_df
#  6   Rolling_xG_Home: create rolling value of colum Home and Away with the same code in roll_df
#  7   Rolling_xG_Away: create rolling value of colum Home and Away with the same code in roll_df
#  8   Rolling_GF: create rolling value of colum Home and Away with the same code in roll_df
#  9   Rolling_GA: create rolling value of colum Home and Away with the same code in roll_df
#  10  mean_Home_GF: input the value from roll_df
#  11  mean_Away_GF: input the value from roll_df
#  12  mean_Venue_GF: input the value from roll_df
#  13  mean_Home_GA: input the value from roll_df
#  14  mean_Away_GA: input the value from roll_df
#  15  mean_Venue_GA: input the value from roll_df

def create_dataframe(home_team, away_team, roll_df):
  """
  Creates a DataFrame with specified columns, including rolling averages.

  Args:
    home_team: The home team name (string).
    away_team: The away team name (string).
    roll_df: The DataFrame containing data for rolling average calculations.

  Returns:
    A pandas DataFrame with the specified columns.
  """

  # Create a new DataFrame with the required columns
  new_df = pd.DataFrame({
      'Home': [home_team],
      'Away': [away_team],
      'Rolling_Avg_xG_Home': roll_df.loc[(roll_df['Home'] == home_team), 'Rolling_Avg_xG_Home'].iloc[-1],
      'Rolling_Avg_xG_Away': roll_df.loc[(roll_df['Away'] == away_team), 'Rolling_Avg_xG_Away'].iloc[-1],
      'Rolling_Avg_GF': roll_df.loc[(roll_df['Home'] == home_team), 'Rolling_Avg_GF'].iloc[-1],
      'Rolling_Avg_GA': roll_df.loc[(roll_df['Away'] == away_team), 'Rolling_Avg_GA'].iloc[-1],
      'Rolling_Avg_Attendance': roll_df.loc[(roll_df['Home'] == home_team), 'Rolling_Avg_Attendance'].iloc[-1],
      'Rolling_xG_Home': roll_df.loc[(roll_df['Home'] == home_team) & (roll_df['Away'] == away_team), 'Rolling_xG_Home'].iloc[-1],
      'Rolling_xG_Away': roll_df.loc[(roll_df['Home'] == home_team) & (roll_df['Away'] == away_team), 'Rolling_xG_Away'].iloc[-1],
      'Rolling_GF': roll_df.loc[(roll_df['Home'] == home_team)  & (roll_df['Away'] == away_team), 'Rolling_GF'].iloc[-1],
      'Rolling_GA': roll_df.loc[(roll_df['Home'] == home_team) & (roll_df['Away'] == away_team), 'Rolling_GA'].iloc[-1],
      'Rolling_Attendance': roll_df.loc[(roll_df['Home'] == home_team)  & (roll_df['Away'] == away_team), 'Rolling_Attendance'].iloc[-1],
      'mean_Home_GF': roll_df.loc[(roll_df['Home'] == home_team), 'mean_Home_GF'].iloc[0],
      'mean_Away_GF': roll_df.loc[(roll_df['Home'] == home_team) & (roll_df['Away'] == away_team), 'mean_Away_GF'].iloc[0],
      'mean_Venue_GF': roll_df.loc[(roll_df['Home'] == home_team), 'mean_Venue_GF'].iloc[0],
      'mean_Home_GA': roll_df.loc[(roll_df['Home'] == home_team), 'mean_Home_GA'].iloc[0],
      'mean_Away_GA': roll_df.loc[(roll_df['Home'] == home_team) & (roll_df['Away'] == away_team), 'mean_Away_GA'].iloc[0],
      'mean_Venue_GA': roll_df.loc[(roll_df['Home'] == home_team), 'mean_Venue_GA'].iloc[0],
  })
  new_df = new_df.drop(columns=(new_df.select_dtypes(include=['object']).columns))
  return new_df

button = st.button('Start Prediction')
if button == True:
  st.write('Prediction Started')
  home_team = st.selectbox("Choose Home Team",
    ('Manchester Utd', 'Ipswich Town', 'Newcastle Utd', "Nott'ham Forest",
     'Everton', 'Arsenal', 'West Ham', 'Brentford', 'Chelsea', 'Leicester City',
     'Brighton', 'Tottenham', 'Fulham', 'Crystal Palace', 'Manchester City',
     'Southampton', 'Aston Villa', 'Bournemouth', 'Wolves', 'Liverpool', 'Watford',
     'West Brom', 'Swansea City', 'Burnley', 'Stoke City', 'Huddersfield',
     'Cardiff City', 'Norwich City', 'Sheffield Utd', 'Leeds United', 'Luton Town'),
                        )
  st.write("You selected:", home_team)

  away_team = st.selectbox("Choose Away Team",
  ('Manchester Utd', 'Ipswich Town', 'Newcastle Utd', "Nott'ham Forest",
    'Everton', 'Arsenal', 'West Ham', 'Brentford', 'Chelsea', 'Leicester City',
    'Brighton', 'Tottenham', 'Fulham', 'Crystal Palace', 'Manchester City',
    'Southampton', 'Aston Villa', 'Bournemouth', 'Wolves', 'Liverpool', 'Watford',
    'West Brom', 'Swansea City', 'Burnley', 'Stoke City', 'Huddersfield',
    'Cardiff City', 'Norwich City', 'Sheffield Utd', 'Leeds United', 'Luton Town'),
                        )
  st.write("You selected:", away_team)
else:
  st.write('Prediction Not Started')

# prompt: i want to make timeline graphics that compare Home last 5 Rolling_xG_Home and last 5 Rolling_xG_Away based on roll_df

import matplotlib.pyplot as plt

def plot_timeline_comparison(roll_df, home_team, away_team, window_size=5):
  """
  Plots a timeline comparison of Rolling_xG_Home and Rolling_xG_Away for the last
  'window_size' games between the specified home and away teams.

  Args:
      roll_df: The DataFrame containing the rolling xG data.
      home_team: The name of the home team.
      away_team: The name of the away team.
      window_size: The number of recent games to consider for the rolling average.
  """

  # Filter the DataFrame to include only games between the specified teams
  team_df = roll_df[(roll_df['Home'] == home_team) & (roll_df['Away'] == away_team)].copy()

  if team_df.empty:
      print(f"No match found between {home_team} and {away_team}.")
      return

  # Extract the relevant columns
  home_xg = team_df['Rolling_xG_Home'].tail(window_size)
  away_xg = team_df['Rolling_xG_Away'].tail(window_size)
  match_dates = team_df.index[-window_size:] # Assuming index represents match dates

  # Create x-axis values (1, 2, 3, 4, ...)
  x_values = list(range(1, window_size + 1))

  # Create the plot
  plt.figure(figsize=(10, 8))

  # Fill the area under the lines
  plt.fill_between(x_values, home_xg, 0, alpha=0.3, label=f"{home_team} Rolling xG (Home)")  # Fill down to 0
  plt.fill_between(x_values, away_xg, 0, alpha=0.3, label=f"{away_team} Rolling xG (Away)")  # Fill down to 0

  plt.plot(x_values, home_xg, label=f"{home_team} Rolling xG (Home)", marker='o')
  plt.plot(x_values, away_xg, label=f"{away_team} Rolling xG (Away)", marker='x')

  for i, txt in enumerate(home_xg):
       plt.annotate(f"{txt:.2f}", (x_values[i], home_xg.iloc[i]), textcoords="offset points", xytext=(0,10), ha='center')
  for i, txt in enumerate(away_xg):
       plt.annotate(f"{txt:.2f}", (x_values[i], away_xg.iloc[i]), textcoords="offset points", xytext=(0,10), ha='center')

  plt.xlabel("Recent Matches")
  plt.ylabel("Average Expected Goals")
  plt.title(f"Average Expected Goals Comparison: {home_team} vs. {away_team}")
  plt.legend()
  plt.grid(True)

  # Set x-axis ticks and labels
  plt.xticks(x_values)  # Set ticks at 1, 2, 3, 4, ...

  plt.tight_layout()
  plt.show()

new_np = np.array(create_dataframe(home_team, away_team, roll_df_normal))

# Make predictions
new_test = mor3.predict(new_np)

print(new_test)

plot_timeline_comparison(roll_df, home_team, away_team)